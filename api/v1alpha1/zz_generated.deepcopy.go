//go:build !ignore_autogenerated

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

import (
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpenClawAgent) DeepCopyInto(out *OpenClawAgent) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpenClawAgent.
func (in *OpenClawAgent) DeepCopy() *OpenClawAgent {
	if in == nil {
		return nil
	}
	out := new(OpenClawAgent)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *OpenClawAgent) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpenClawAgentList) DeepCopyInto(out *OpenClawAgentList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]OpenClawAgent, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpenClawAgentList.
func (in *OpenClawAgentList) DeepCopy() *OpenClawAgentList {
	if in == nil {
		return nil
	}
	out := new(OpenClawAgentList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *OpenClawAgentList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpenClawAgentSpec) DeepCopyInto(out *OpenClawAgentSpec) {
	*out = *in
	if in.Runtime != nil {
		in, out := &in.Runtime, &out.Runtime
		*out = new(RuntimeSpec)
		(*in).DeepCopyInto(*out)
	}
	if in.Identity != nil {
		in, out := &in.Identity, &out.Identity
		*out = new(PersonalitySource)
		**out = **in
	}
	if in.Soul != nil {
		in, out := &in.Soul, &out.Soul
		*out = new(PersonalitySource)
		**out = **in
	}
	if in.Memory != nil {
		in, out := &in.Memory, &out.Memory
		*out = new(MemorySpec)
		(*in).DeepCopyInto(*out)
	}
	if in.Swarm != nil {
		in, out := &in.Swarm, &out.Swarm
		*out = new(SwarmSpec)
		(*in).DeepCopyInto(*out)
	}
	if in.Mutability != nil {
		in, out := &in.Mutability, &out.Mutability
		*out = new(MutabilitySpec)
		(*in).DeepCopyInto(*out)
	}
	if in.Capabilities != nil {
		in, out := &in.Capabilities, &out.Capabilities
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.Resources != nil {
		in, out := &in.Resources, &out.Resources
		*out = new(corev1.ResourceRequirements)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpenClawAgentSpec.
func (in *OpenClawAgentSpec) DeepCopy() *OpenClawAgentSpec {
	if in == nil {
		return nil
	}
	out := new(OpenClawAgentSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpenClawAgentStatus) DeepCopyInto(out *OpenClawAgentStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]metav1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Memory != nil {
		in, out := &in.Memory, &out.Memory
		*out = new(MemoryStatus)
		**out = **in
	}
	if in.Swarm != nil {
		in, out := &in.Swarm, &out.Swarm
		*out = new(SwarmStatus)
		**out = **in
	}
	if in.StartTime != nil {
		in, out := &in.StartTime, &out.StartTime
		*out = (*in).DeepCopy()
	}
	if in.LastHeartbeat != nil {
		in, out := &in.LastHeartbeat, &out.LastHeartbeat
		*out = (*in).DeepCopy()
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpenClawAgentStatus.
func (in *OpenClawAgentStatus) DeepCopy() *OpenClawAgentStatus {
	if in == nil {
		return nil
	}
	out := new(OpenClawAgentStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpenClawSwarm) DeepCopyInto(out *OpenClawSwarm) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpenClawSwarm.
func (in *OpenClawSwarm) DeepCopy() *OpenClawSwarm {
	if in == nil {
		return nil
	}
	out := new(OpenClawSwarm)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *OpenClawSwarm) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpenClawSwarmList) DeepCopyInto(out *OpenClawSwarmList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]OpenClawSwarm, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpenClawSwarmList.
func (in *OpenClawSwarmList) DeepCopy() *OpenClawSwarmList {
	if in == nil {
		return nil
	}
	out := new(OpenClawSwarmList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *OpenClawSwarmList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpenClawSwarmSpec) DeepCopyInto(out *OpenClawSwarmSpec) {
	*out = *in
	if in.WorkerSelector != nil {
		in, out := &in.WorkerSelector, &out.WorkerSelector
		*out = new(metav1.LabelSelector)
		(*in).DeepCopyInto(*out)
	}
	if in.Timeout != nil {
		in, out := &in.Timeout, &out.Timeout
		*out = new(metav1.Duration)
		**out = **in
	}
	if in.Constraints != nil {
		in, out := &in.Constraints, &out.Constraints
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpenClawSwarmSpec.
func (in *OpenClawSwarmSpec) DeepCopy() *OpenClawSwarmSpec {
	if in == nil {
		return nil
	}
	out := new(OpenClawSwarmSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpenClawSwarmStatus) DeepCopyInto(out *OpenClawSwarmStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]metav1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Workers != nil {
		in, out := &in.Workers, &out.Workers
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.StartTime != nil {
		in, out := &in.StartTime, &out.StartTime
		*out = (*in).DeepCopy()
	}
	if in.CompletionTime != nil {
		in, out := &in.CompletionTime, &out.CompletionTime
		*out = (*in).DeepCopy()
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpenClawSwarmStatus.
func (in *OpenClawSwarmStatus) DeepCopy() *OpenClawSwarmStatus {
	if in == nil {
		return nil
	}
	out := new(OpenClawSwarmStatus)
	in.DeepCopyInto(out)
	return out
}

// Remaining DeepCopy functions for nested types

func (in *RuntimeSpec) DeepCopyInto(out *RuntimeSpec) {
	*out = *in
	if in.Command != nil {
		in, out := &in.Command, &out.Command
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.Args != nil {
		in, out := &in.Args, &out.Args
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.Env != nil {
		in, out := &in.Env, &out.Env
		*out = make([]corev1.EnvVar, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

func (in *RuntimeSpec) DeepCopy() *RuntimeSpec {
	if in == nil {
		return nil
	}
	out := new(RuntimeSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *MemorySpec) DeepCopyInto(out *MemorySpec) {
	*out = *in
	if in.Company != nil {
		in, out := &in.Company, &out.Company
		*out = new(CompanyMemorySpec)
		(*in).DeepCopyInto(*out)
	}
	if in.Group != nil {
		in, out := &in.Group, &out.Group
		*out = new(GroupMemorySpec)
		(*in).DeepCopyInto(*out)
	}
	if in.Swarm != nil {
		in, out := &in.Swarm, &out.Swarm
		*out = new(SwarmMemorySpec)
		**out = **in
	}
	if in.Individual != nil {
		in, out := &in.Individual, &out.Individual
		*out = new(IndividualMemorySpec)
		(*in).DeepCopyInto(*out)
	}
}

func (in *MemorySpec) DeepCopy() *MemorySpec {
	if in == nil {
		return nil
	}
	out := new(MemorySpec)
	in.DeepCopyInto(out)
	return out
}

func (in *CompanyMemorySpec) DeepCopyInto(out *CompanyMemorySpec) {
	*out = *in
	if in.Buckets != nil {
		in, out := &in.Buckets, &out.Buckets
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

func (in *CompanyMemorySpec) DeepCopy() *CompanyMemorySpec {
	if in == nil {
		return nil
	}
	out := new(CompanyMemorySpec)
	in.DeepCopyInto(out)
	return out
}

func (in *GroupMemorySpec) DeepCopyInto(out *GroupMemorySpec) {
	*out = *in
	if in.CrossGroupRead != nil {
		in, out := &in.CrossGroupRead, &out.CrossGroupRead
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

func (in *GroupMemorySpec) DeepCopy() *GroupMemorySpec {
	if in == nil {
		return nil
	}
	out := new(GroupMemorySpec)
	in.DeepCopyInto(out)
	return out
}

func (in *IndividualMemorySpec) DeepCopyInto(out *IndividualMemorySpec) {
	*out = *in
	if in.TTL != nil {
		in, out := &in.TTL, &out.TTL
		*out = new(metav1.Duration)
		**out = **in
	}
}

func (in *IndividualMemorySpec) DeepCopy() *IndividualMemorySpec {
	if in == nil {
		return nil
	}
	out := new(IndividualMemorySpec)
	in.DeepCopyInto(out)
	return out
}

func (in *SwarmSpec) DeepCopyInto(out *SwarmSpec) {
	*out = *in
	if in.Groups != nil {
		in, out := &in.Groups, &out.Groups
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.ShardTimeout != nil {
		in, out := &in.ShardTimeout, &out.ShardTimeout
		*out = new(metav1.Duration)
		**out = **in
	}
}

func (in *SwarmSpec) DeepCopy() *SwarmSpec {
	if in == nil {
		return nil
	}
	out := new(SwarmSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *MutabilitySpec) DeepCopyInto(out *MutabilitySpec) {
	*out = *in
	if in.ToolPaths != nil {
		in, out := &in.ToolPaths, &out.ToolPaths
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

func (in *MutabilitySpec) DeepCopy() *MutabilitySpec {
	if in == nil {
		return nil
	}
	out := new(MutabilitySpec)
	in.DeepCopyInto(out)
	return out
}
